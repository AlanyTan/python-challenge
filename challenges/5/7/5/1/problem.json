{
    "title": "Scheduling playoff matches",
    "goal": "Leverage data structure, flow control and data types to solvepractical schedule playoff matches problem",
    "description": "Design a function that schedule playoff (elimination) games. \nThe returned value should be a dictionary like:{('day_8_am', 'east'): ((1,8), '1/4')} \nwhere the key is a tuple of (time, field), \n and the value is a tuple that contains another tuple and a string, \n  where the inner tuple is (guest, host),\n   guest is the game# from which the guest team should come from,\n   and host is the game# from which the host team should come from; \n the string is the round name of which the teams are drawn from.\ni.e. for quarter final, the string is '1/4', and first game \n should be (1, 8) where 1 means team had highest standing from \n the previous round, and 8 means the team had 8th standing from \n the previous round;for semi-final, the round string should be '1/2', and the first \n game should be (1, 4) where 1 means game #1 of quarter-final \n (where highest ranked team played), and 4 means game #4 of \n quarter-final, (where 4th) ranked team played the 5th ranked team",
    "notes": "\n1) you don't need to use winner_of() function for the actual solution, it is proivided for testing your solution to see if the games scheduled played out as expected; \n2) you can create and use other functions as you wish, but the one we will test is solution(playoff_teams, time_field_availability)",
    "condition_code": "\n# number of teams that will be playing playoff games\n# for now, we only handle no_of_playoff_teams = 2**n, which means all teams\n# have equal chances and same expected path to win (other number of playoff\n# teams will require some teams to skip certain rounds, which we won't worry\n# about for this challenge)\nno_of_playoff_teams = 8\n\n# Usually, out of all the playoff_teams, they will be ranked by points they\n# earned during group round robin games, and the highest ranked team will\n# play the lowest ranked team, the following is a simulation of the teams:\nplayoff_teams = [f\"Team_{t+65:c}\" for t in range(no_of_playoff_teams)]\n\ntime_field_availability = {\n    'day_8_am': ['east', 'west', 'north', 'south'],\n    'day_8_pm': ['east', 'west', 'north', 'south'],\n    'day_9_am': ['east', 'west', 'north', 'south'],\n    'day_9_pm': ['east', 'west', 'north', 'south'],\n}\n\n\n# function similate game report which team won their game\ndef winner_of(team_a: str, team_b: str) -> str:\n    #report game results, who won\n    game_played = True\n    if game_played:\n        return max(team_a, team_b)\n    else:\n        return f\"winner between {team_a, team_b}\"\n",
    "starting_code": "\n\ndef schedule_playoff_matches(playoff_teams: list) -> dict:\n    # replace the below pass with your code to finish this function\n    # return a dict like {('day_8_am', 'east'): ((1,8), '1/4'), \n    # ('day_8_pm', 'west'): ((2,7), '1/4')...}\n    pass\n\n    \ndef solution(playoff_teams, time_field_availability):\n    # Convert time_field_availability dict to list[(time,field)] sequence\n    fields_available = ((time, field) for time in time_field_availability\n                    for field in time_field_availability[time] if field)\n    return schedule_playoff_matches(playoff_teams, fields_available)\n\nif __name__ == \"__main__\":\n    # playoff_matches are:\n    # {((prev_round_match_#1, prev_round_match_#2), round): (time, field)}\n    playoff_matches = schedule_playoff_matches(playoff_teams)\n",
    "expected_output": "",
    "test_cases": []
}